// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: batch.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const confirmBatch = `-- name: ConfirmBatch :exec
UPDATE
        sweep_batches
SET
        batch_state = 'confirmed'
WHERE
        id = $1
`

func (q *Queries) ConfirmBatch(ctx context.Context, id []byte) error {
	_, err := q.db.ExecContext(ctx, confirmBatch, id)
	return err
}

const getBatchSweeps = `-- name: GetBatchSweeps :many
SELECT
        sweeps.id, sweeps.swap_hash, sweeps.batch_id, sweeps.outpoint_txid, sweeps.outpoint_index, sweeps.amt,
        swaps.id, swaps.swap_hash, swaps.preimage, swaps.initiation_time, swaps.amount_requested, swaps.cltv_expiry, swaps.max_miner_fee, swaps.max_swap_fee, swaps.initiation_height, swaps.protocol_version, swaps.label,
        loopout_swaps.swap_hash, loopout_swaps.dest_address, loopout_swaps.swap_invoice, loopout_swaps.max_swap_routing_fee, loopout_swaps.sweep_conf_target, loopout_swaps.htlc_confirmations, loopout_swaps.outgoing_chan_set, loopout_swaps.prepay_invoice, loopout_swaps.max_prepay_routing_fee, loopout_swaps.publication_deadline, loopout_swaps.is_wallet_addr,
        htlc_keys.swap_hash, htlc_keys.sender_script_pubkey, htlc_keys.receiver_script_pubkey, htlc_keys.sender_internal_pubkey, htlc_keys.receiver_internal_pubkey, htlc_keys.client_key_family, htlc_keys.client_key_index
FROM
        sweeps
JOIN
        swaps ON sweeps.swap_hash = swaps.swap_hash
JOIN
        loopout_swaps ON sweeps.swap_hash = loopout_swaps.swap_hash
JOIN
        htlc_keys ON sweeps.swap_hash = htlc_keys.swap_hash
WHERE
        sweeps.batch_id = $1
ORDER BY
        sweeps.id ASC
`

type GetBatchSweepsRow struct {
	ID                     int32
	SwapHash               []byte
	BatchID                []byte
	OutpointTxid           []byte
	OutpointIndex          int32
	Amt                    int32
	ID_2                   int32
	SwapHash_2             []byte
	Preimage               []byte
	InitiationTime         time.Time
	AmountRequested        int64
	CltvExpiry             int32
	MaxMinerFee            int64
	MaxSwapFee             int64
	InitiationHeight       int32
	ProtocolVersion        int32
	Label                  string
	SwapHash_3             []byte
	DestAddress            string
	SwapInvoice            string
	MaxSwapRoutingFee      int64
	SweepConfTarget        int32
	HtlcConfirmations      int32
	OutgoingChanSet        string
	PrepayInvoice          string
	MaxPrepayRoutingFee    int64
	PublicationDeadline    time.Time
	IsWalletAddr           bool
	SwapHash_4             []byte
	SenderScriptPubkey     []byte
	ReceiverScriptPubkey   []byte
	SenderInternalPubkey   []byte
	ReceiverInternalPubkey []byte
	ClientKeyFamily        int32
	ClientKeyIndex         int32
}

func (q *Queries) GetBatchSweeps(ctx context.Context, batchID []byte) ([]GetBatchSweepsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBatchSweeps, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBatchSweepsRow
	for rows.Next() {
		var i GetBatchSweepsRow
		if err := rows.Scan(
			&i.ID,
			&i.SwapHash,
			&i.BatchID,
			&i.OutpointTxid,
			&i.OutpointIndex,
			&i.Amt,
			&i.ID_2,
			&i.SwapHash_2,
			&i.Preimage,
			&i.InitiationTime,
			&i.AmountRequested,
			&i.CltvExpiry,
			&i.MaxMinerFee,
			&i.MaxSwapFee,
			&i.InitiationHeight,
			&i.ProtocolVersion,
			&i.Label,
			&i.SwapHash_3,
			&i.DestAddress,
			&i.SwapInvoice,
			&i.MaxSwapRoutingFee,
			&i.SweepConfTarget,
			&i.HtlcConfirmations,
			&i.OutgoingChanSet,
			&i.PrepayInvoice,
			&i.MaxPrepayRoutingFee,
			&i.PublicationDeadline,
			&i.IsWalletAddr,
			&i.SwapHash_4,
			&i.SenderScriptPubkey,
			&i.ReceiverScriptPubkey,
			&i.SenderInternalPubkey,
			&i.ReceiverInternalPubkey,
			&i.ClientKeyFamily,
			&i.ClientKeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconfirmedBatches = `-- name: GetUnconfirmedBatches :many
SELECT
        id, batch_state, batchtxid, batchpkscript, lastrbfheight, lastrbfsatperkw, maxtimeoutdistance
FROM
        sweep_batches
WHERE
        batch_state != 'confirmed'
`

func (q *Queries) GetUnconfirmedBatches(ctx context.Context) ([]SweepBatch, error) {
	rows, err := q.db.QueryContext(ctx, getUnconfirmedBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SweepBatch
	for rows.Next() {
		var i SweepBatch
		if err := rows.Scan(
			&i.ID,
			&i.BatchState,
			&i.Batchtxid,
			&i.Batchpkscript,
			&i.Lastrbfheight,
			&i.Lastrbfsatperkw,
			&i.Maxtimeoutdistance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBatch = `-- name: UpsertBatch :exec
INSERT INTO sweep_batches (
        id,
        batch_state,
        batchTxid,
        batchPkScript,
        lastRbfHeight,
        lastRbfSatPerKw,
        maxTimeoutDistance
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7
) ON CONFLICT (id) DO UPDATE SET
        batch_state = $2,
        batchTxid = $3,
        batchPkScript = $4,
        lastRbfHeight = $5,
        lastRbfSatPerKw = $6
`

type UpsertBatchParams struct {
	ID                 []byte
	BatchState         string
	Batchtxid          sql.NullString
	Batchpkscript      []byte
	Lastrbfheight      sql.NullInt32
	Lastrbfsatperkw    sql.NullInt32
	Maxtimeoutdistance int32
}

func (q *Queries) UpsertBatch(ctx context.Context, arg UpsertBatchParams) error {
	_, err := q.db.ExecContext(ctx, upsertBatch,
		arg.ID,
		arg.BatchState,
		arg.Batchtxid,
		arg.Batchpkscript,
		arg.Lastrbfheight,
		arg.Lastrbfsatperkw,
		arg.Maxtimeoutdistance,
	)
	return err
}

const upsertSweep = `-- name: UpsertSweep :exec
INSERT INTO sweeps (
        swap_hash,
        batch_id,
        outpoint_txid,
        outpoint_index,
        amt
) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5
) ON CONFLICT (swap_hash) DO UPDATE SET
        batch_id = $2,
        outpoint_txid = $3,
        outpoint_index = $4,
        amt = $5
`

type UpsertSweepParams struct {
	SwapHash      []byte
	BatchID       []byte
	OutpointTxid  []byte
	OutpointIndex int32
	Amt           int32
}

func (q *Queries) UpsertSweep(ctx context.Context, arg UpsertSweepParams) error {
	_, err := q.db.ExecContext(ctx, upsertSweep,
		arg.SwapHash,
		arg.BatchID,
		arg.OutpointTxid,
		arg.OutpointIndex,
		arg.Amt,
	)
	return err
}
